+++
draft = true
title = "Sidetracked: Introducing JWT Authentication"
[taxonomies]
tags = ["sidetracked", "rust"]
[extra]
toc = true
repo_link = "https://github.com/elidhu/sidetracked/tree/2024-04-15_introducting-jwt-authentication"
+++

> In this article, we are going to introduce the concept of users to Sidetracked. We will also implement a basic authentication system using JSON Web Tokens (JWTs).<!-- more -->

## Users Already?

You might be thinking, "Users already? We just started! I thought this was a todo app?" And you would be correct. We are building a todo app, but we need to have a way to identify who is creating, updating, and deleting todos. We could just use a single user for the entire application, but that would be boring. To be perfectly honest, I did start writing the code for todo creation before deciding that I actually need to add users first.

Todos are owned by users, at least in this app. One day I would even like for users to be able to share their todos with others. As I was planning out what the resource path for a todo would look like, I realised that I wanted `users/` to be a part of it. Something like this:

```txt
/users/{:id}/todos/{:id}
```

This would allow for one user to access the todos of another with the appropriate permissions.

## A Plan

Okay, so I have a little bit of a plan for how we are going to do users. For now, we aren't going to worry about passwords and signup etc. What we are going to do is use JWTs that we will generate using [JWT.IO](https://jwt.io/). The generated JWTs will use a _super secret value_ that we will also use in our application when validating the JWT. Effectively pretending the JWT was generated by a trusted Identity Provider (IdP). This JWT payload will contain all the information we need to identify the user. Something like:

```json
{
  "sub": "018eef43-1283-70dd-b738-5bc64b3313c5",
  "name": "Jason Asano",
  "iat": 1713411102,
  "exp": 1913411102
}
```

In summary, if we receive a JWT that we can validate with our _super secret value_, we will trust the payload and use it to identify the user. This means either fetching the user from a data store or creating a new user if they don't exist.

Just to lay it out simply, we are going to work through the following:

- Generate a JWT
- Validate the JWT
- Create a middleware to handle JWTs, including triggering the creation of a user if they don't exist
- Implement a user model
- Implement a user service
- Implement a route at `/profile` for users to view their profile
- Protect all routes with the middleware

## Starting with a Test

Let's continue our outside-in approach by writing a test for the `/profile` route. The simplest thing for us to test at this stage is that it returns a `401 Unauthorized` if no JWT is provided. Once we have that up and running we will move on to what to do when a JWT is provided!

In the same test file as our health check test, let's add a new in-line module to contain our `/profile` tests.

```rust
#[cfg(test)]
mod test_profile {
    use super::*;

  // New tests go here
}
```

We want a `401 Unauthorized` if no JWT is provided in the Authorization header i.e. we **DON'T** receive a header like this: `Authorization: Bearer <JWT>`. Note this test isn't actually covering the case where a JWT is provided but is invalid. We will cover that in a later test.

```rust
// ./sidetracked/tests/routes.rs

    #[tokio::test]
    async fn it_should_return_401() {
        // Arrange
        let mut app = helpers::new_test_app().await;
        app.expect_failure();

        // Act
        let response = app.get("/profile").await;

        // Assert
        response.assert_status(StatusCode::UNAUTHORIZED);
    }
```

Now we are going to implement the required code to make this pass in one big step. We won't be doing the minimal TDD approach here.

## Setting up JWT Validation

The first thing we need to do is add a library that will help us to validate and parse JWTs. I have some experience with [jwt-authorizer](https://crates.io/crates/jwt-authorizer) so I am going to use that.

From the usage example in the documentation we see that we need to do the following things:

- Create an `Authorizer` with suitable configuration for our use-case.
- Add that authorizer to our routes in such a way that it applies to the routes we want to protect.
- Use an extractor to get the validated claims in our profile route handler.

# MY STEPS

Add some dependencies

```
cargo add jwt-authorizer anyhow
```

Also some dev dependencies (just for testing)

```txt
cargo add --dev jwt sha2 hmac
```

Create the claims struct

```rust
// ./sidetracked/src/web/auth.rs

#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
pub struct Claims {
    pub sub: String,
    pub name: String,
    pub iat: i64,
    pub exp: i64,
}
```

Add `Authorizer` to the `Application` struct.

```rust
// ./sidetracked/src/web/application.rs

pub struct Application {
    authorizer: Arc<Authorizer<Claims>>,
}
```

Create a constructor for the `Application` struct.

```rust
// ./sidetracked/src/web/application.rs

    /// Create a new application with the provided authorizer
    pub fn new(authorizer: Authorizer<Claims>) -> Self {
        Self {
            authorizer: Arc::new(authorizer),
        }
    }
```

Add another specialised constructor to give us an `Application` with an `Authorizer` that grabs a secret from the environment.

```rust
// ./sidetracked/src/web/application.rs

    /// Create a new application with a default authorizer that expects a secret to be set in the
    /// `SIDETRACKED_SECRET` environment variable.
    pub async fn new_with_default_authorizer() -> Result<Self> {
        let secret = std::env::var("SIDETRACKED_SECRET").context("SIDETRACKED_SECRET not set")?;

        let authorizer = AuthorizerBuilder::<Claims>::from_secret(&secret)
            .jwt_source(JwtSource::AuthorizationHeader)
            .build()
            .await?;

        Ok(Self::new(authorizer))
    }
```

Modify the Router to split the routes into protected and unprotected.

```rust
// ./sidetracked/src/web/application.rs

        let protected = Router::new()
            // Add a profile route
            .route("/profile", get(profile))
            // Add the authorizer layer
            .layer(ServiceBuilder::new().layer(self.authorizer.clone().into_layer()));

        let unprotected = Router::new()
            // Add a health check route
            .route("/health_check", get(health_check));

        Router::new()
            .merge(protected)
            .merge(unprotected)
            // Add `TraceLayer` to log all incoming requests
            .layer(ServiceBuilder::new().layer(TraceLayer::new_for_http()))
```

Update main to use the new constructor.

```rust
// ./sidetracked/src/main.rs

#[tokio::main]
async fn main() {
    init_logging();

    let config = ApplicationConfig::default();

    let app = Application::new_with_default_authorizer()
        .await
        .expect("Failed to build application");

    run(app, config).await;
}
```

Run the original `401 Unauthorized` test.

```txt
     Running tests/routes.rs (target/debug/deps/routes-fc2627eea41f5e01)

running 2 tests
test test_profile::it_should_return_401 ... ok
test test_health_check::it_should_return_200 ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.01s
```

Great! Our test is passing. Now we need to add a test for when a JWT is provided. We are going to check 2 things in this test. Firstly, that the route returns a `200 OK` status code. Secondly, that the claims we expect are returned in the response body.

Let's create a little helper to minimise some of the awkwardness of working with the `Authorizer` and `Claims`. Firstly, lets hard code a secret into the tests that the authorizer can use. We need a secret that we can use that is consistent between the authorizer and the other helper we will write to sign our claims. This way we can generate a JWT with `Claims` we decide on that the authorizer will accept.

```rust
// ./sidetracked/tests/helpers/mod.rs

const TEST_SECRET: &str = "7750e0e7ad62179c3a5299f40ec6fb69fffa0b95aff0424955f654012e5cedb5";
```

Following that we will write a helper to sign claims with the secret we have defined.

```rust
// ./sidetracked/tests/helpers/mod.rs

#[cfg(test)]
pub async fn new_test_token(claims: Claims) -> String {
    let key: Hmac<Sha256> =
        Hmac::new_from_slice(TEST_SECRET.as_bytes()).expect("Failed to create key");

    claims.sign_with_key(&key).expect("Failed to sign token")
}
```

Finally we actually need to add the authorizer to our `new_test_app` helper so that we can use it in our tests.

```rust
// ./sidetracked/tests/helpers/mod.rs

#[cfg(test)]
pub async fn new_test_app() -> TestServer {
    let authorizer = AuthorizerBuilder::<Claims>::from_secret(TEST_SECRET)
        .jwt_source(JwtSource::AuthorizationHeader)
        .build()
        .await
        .expect("Failed to build authorizer");

    let app = Application::new(authorizer);

    let config = TestServerConfig::builder()
        // Use an actual HTTP transport on a random port.
        .http_transport()
        // Behave like a browser and save cookies between requests.
        .save_cookies()
        // We are testing a JSON API.
        .default_content_type("application/json")
        // Panic if the response is outside the 2XX range (Unless request marked as expected failure).
        .expect_success_by_default()
        .build();

    TestServer::new_with_config(app.router(), config).unwrap()
}
```

Finally we can write the test.

```rust
// ./sidetracked/tests/routes.rs

    #[tokio::test]
    async fn it_should_return_200() {
        // Arrange
        let mut app = helpers::new_test_app().await;

        // Construct some valid claims
        let test_claims = Claims {
            sub: "018eef43-1283-70dd-b738-5bc64b3313c5".to_string(),
            name: "Jason Asano".to_string(),
            iat: 1713411102,
            exp: 1913411102,
        };

        // Sign the claims to create a token
        let test_token = helpers::new_test_token(test_claims.clone()).await;

        // Add the token to the Authorization header
        app.add_header(
            AUTHORIZATION,
            HeaderValue::from_str(&format!("Bearer {test_token}")).unwrap(),
        );

        // Act
        let response = app.get("/profile").await;

        // Assert
        response.assert_status(StatusCode::OK);
        response.assert_json::<Claims>(&test_claims);
    }
```

Let's briefly go over what this test actually does.

First we create a `Claims` struct containing the appropriate information for the user we are pretending to be. We then use our `new_test_token` helper to sign these claims and create a JWT. We then make a request to the `/profile` route with the JWT in the Authorization header. Finally, we check that the response status is `200 OK` and that the response body contains the claims we expect.


